/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.strangegrotto.clijournal;

import com.google.common.collect.Sets;
import com.strangegrotto.clijournal.commands.CommandParser;
import com.strangegrotto.clijournal.commands.CommandResultMetadata;
import com.strangegrotto.clijournal.commands.CommandResultsRecord;
import com.strangegrotto.clijournal.commands.ResultReferenceTranslator;
import com.strangegrotto.clijournal.commands.verbs.*;
import com.strangegrotto.clijournal.entrystore.EntryStore;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Set;

public class Main {
    private static final Set<String> BLACKLISTED_FILENAME_PATTERNS = Sets.newHashSet(
            ".*\\.swp",
            "^\\.git"
    );

    public static void main(String[] args) throws InterruptedException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        Path journalDirpath = null;
        try {
            journalDirpath = getJournalDirpathFromConfig(reader);
        } catch (IOException e) {
            System.out.println("Fatal error reading config: " + e.getMessage());
            System.exit(1);
        }

        EntryStore entryStore = null;
        try {
            entryStore = new EntryStore(journalDirpath, BLACKLISTED_FILENAME_PATTERNS);
        } catch (IOException e) {
            System.out.println("Fatal error initializing entry store: " + e.getMessage());
            System.exit(1);
        }

        CommandResultsRecord resultsRecord = new CommandResultsRecord();
        ResultReferenceTranslator referenceTranslator = new ResultReferenceTranslator(resultsRecord);
        CommandParser commandParser = new CommandParser(resultsRecord).registerCommand(
                new ListEntriesCommand(entryStore)
        ).registerCommand(
                new ListTagsCommand(entryStore)
        ).registerCommand(
                new FindEntriesCommand(entryStore)
        ).registerCommand(
                new VimCommand(entryStore, referenceTranslator)
        ).registerCommand(
                new NewEntryCommand(entryStore, referenceTranslator)
        ).registerCommand(
                new QuitCommand()
        );

        List<String> endArgs = runInputLoop(reader, commandParser, args);
        if (endArgs.size() > 0) {
            Process process = null;
            try {
                process = new ProcessBuilder(endArgs).inheritIO().start();
            } catch (IOException e) {
                System.out.println("Fatal error starting subprocess: " + e.getMessage());
                System.exit(1);
            }
            process.waitFor();
        }
    }

    /**
     * Main input loop during the user's operation of the program
     * @param reader Reader to use when reading user's input
     * @param commandParser Command parser to parse the user's tokenized input
     * @param cliArgs Optional args that were passed into this CLI from the shell, and which should be run first
     * @return Potential list of arguments to end the CLI with
     * @throws IOException
     */
    private static List<String> runInputLoop(BufferedReader reader, CommandParser commandParser, String[] cliArgs) {
        boolean useCliArgs = cliArgs.length > 0;
        Optional<List<String>> endArgsOpt = Optional.empty();
        while (!endArgsOpt.isPresent()) {
            System.out.print("\n>> ");
            List<String> tokenizedInput;
            if (!useCliArgs) {
                String userInput;
                try {
                    userInput = reader.readLine();
                } catch (IOException e) {
                    System.out.println("An error occurred reading your input; please try again");
                    continue;
                }
                if (null == userInput) {
                    endArgsOpt = Optional.of(List.of());
                    break;
                }

                tokenizedInput = Arrays.asList(userInput.trim().split("\\s+"));
                if (tokenizedInput.size() == 0) {
                    continue;
                }
            } else {
                tokenizedInput = Arrays.asList(cliArgs);
                useCliArgs = false;
            }

            CommandResultMetadata cmdResult = commandParser.parse(tokenizedInput);

            endArgsOpt = cmdResult.getEndArgs();
        }
        return endArgsOpt.get();
    }


}
