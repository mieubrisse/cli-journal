/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.strangegrotto.clijournal;

import com.google.common.collect.Sets;
import com.strangegrotto.clijournal.commands.CommandParser;
import com.strangegrotto.clijournal.commands.CommandResultMetadata;
import com.strangegrotto.clijournal.commands.CommandResultsRecord;
import com.strangegrotto.clijournal.commands.ResultReferenceTranslator;
import com.strangegrotto.clijournal.commands.verbs.*;
import com.strangegrotto.clijournal.config.ConfigLoader;
import com.strangegrotto.clijournal.config.ConfigV1;
import com.strangegrotto.clijournal.config.InvalidConfigException;
import com.strangegrotto.clijournal.entrystore.EntryStore;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class Main {
    private static final Set<String> BLACKLISTED_FILENAME_PATTERNS = Sets.newHashSet(
            ".*\\.swp",
            "^\\.git"
    );

    public static void main(String[] args) throws InterruptedException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        ConfigLoader configLoader = new ConfigLoader(reader);

        ConfigV1 config = null;
        try {
            config = configLoader.loadConfig();
        } catch (IOException e) {
            System.out.println("An unrecoverable IO error occurred reading/writing the config file:");
            System.out.println(e.getMessage());
            System.exit(1);
        } catch (InvalidConfigException e) {
            System.out.println("We parsed the config file successfully, but it failed validation:");
            System.out.println(e.getMessage());
            System.out.println("Please correct the config file and re-run the CLI");
            System.exit(1);
        }

        Map<String, String> contextDirpaths = config.getContextDirpaths();
        String initContext = config.getDefaultContext();
        if (args.length > 0 && contextDirpaths.containsKey(args[0])) {
            initContext = args[0];
            args = Arrays.copyOfRange(args, 1, args.length);
        }
        Path journalDirpath = Paths.get(contextDirpaths.get(initContext));

        EntryStore entryStore = null;
        try {
            entryStore = new EntryStore(journalDirpath, BLACKLISTED_FILENAME_PATTERNS);
        } catch (IOException e) {
            System.out.println("Fatal error initializing entry store: " + e.getMessage());
            System.exit(1);
        }

        CommandResultsRecord resultsRecord = new CommandResultsRecord();
        ResultReferenceTranslator referenceTranslator = new ResultReferenceTranslator(resultsRecord);

        // TODO add commands to list the context and change the context
        CommandParser commandParser = new CommandParser(resultsRecord).registerCommand(
                new ListEntriesCommand(entryStore)
        ).registerCommand(
                new ListTagsCommand(entryStore)
        ).registerCommand(
                new FindEntriesCommand(entryStore)
        ).registerCommand(
                new VimCommand(entryStore, referenceTranslator)
        ).registerCommand(
                new NewEntryCommand(entryStore, referenceTranslator)
        ).registerCommand(
                new QuitCommand()
        );

        List<String> endArgs = runInputLoop(reader, commandParser, args);
        if (endArgs.size() > 0) {
            Process process = null;
            try {
                process = new ProcessBuilder(endArgs).inheritIO().start();
            } catch (IOException e) {
                System.out.println("Fatal error starting subprocess: " + e.getMessage());
                System.exit(1);
            }
            process.waitFor();
        }
    }

    /**
     * Main input loop during the user's operation of the program
     * @param reader Reader to use when reading user's input
     * @param commandParser Command parser to parse the user's tokenized input
     * @param cliArgs Optional args that were passed into this CLI from the shell, and which should be run first
     * @return Potential list of arguments to end the CLI with
     * @throws IOException
     */
    private static List<String> runInputLoop(BufferedReader reader, CommandParser commandParser, String[] cliArgs) {
        boolean useCliArgs = cliArgs.length > 0;
        Optional<List<String>> endArgsOpt = Optional.empty();
        while (!endArgsOpt.isPresent()) {
            System.out.print("\n>> ");
            List<String> tokenizedInput;
            if (!useCliArgs) {
                String userInput;
                try {
                    userInput = reader.readLine();
                } catch (IOException e) {
                    System.out.println("An error occurred reading your input; please try again");
                    continue;
                }
                if (null == userInput) {
                    endArgsOpt = Optional.of(List.of());
                    break;
                }

                tokenizedInput = Arrays.asList(userInput.trim().split("\\s+"));
                if (tokenizedInput.size() == 0) {
                    continue;
                }
            } else {
                tokenizedInput = Arrays.asList(cliArgs);
                useCliArgs = false;
            }

            CommandResultMetadata cmdResult = commandParser.parse(tokenizedInput);

            endArgsOpt = cmdResult.getEndArgs();
        }
        return endArgsOpt.get();
    }


}
